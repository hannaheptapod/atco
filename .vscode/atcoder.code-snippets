{
    "Barrett": {
        "body": [
            "class Barrett:",
            "    def mul(self, a, b):",
            "        assert 0 <= a < self._m",
            "        assert 0 <= b < self._m",
            "        z = a * b",
            "        v = z - ((z * self.im)>>64) * self._m",
            "        if v < 0: v += self._m",
            "        return v"
        ],
        "description": [
            "https://qiita.com/R_olldIce/items/cebb1f15bf482fddd85e#4-barrett"
        ],
        "prefix": "Barrett"
    },
    "DSU": {
        "body": [
            "class DSU:",
            "    def __init__(self, n):",
            "        self._n = n",
            "        self.parent_or_size = [-1] * n",
            "",
            "    def merge(self, a, b):",
            "        assert 0 <= a < self._n",
            "        assert 0 <= b < self._n",
            "        x, y = self.leader(a), self.leader(b)",
            "        if x == y: return x",
            "        if -self.parent_or_size[x] < -self.parent_or_size[y]: x, y = y, x",
            "        self.parent_or_size[x] += self.parent_or_size[y]",
            "        self.parent_or_size[y] = x",
            "        return x",
            "",
            "    def same(self, a, b):",
            "        assert 0 <= a < self._n",
            "        assert 0 <= b < self._n",
            "        return self.leader(a) == self.leader(b)",
            "",
            "    def leader(self, a):",
            "        assert 0 <= a < self._n",
            "        if self.parent_or_size[a] < 0: return a",
            "        self.parent_or_size[a] = self.leader(self.parent_or_size[a])",
            "        return self.parent_or_size[a]",
            "",
            "    def size(self, a):",
            "        assert 0 <= a < self._n",
            "        return -self.parent_or_size[self.leader(a)]",
            "",
            "    def groups(self):",
            "        leader_buf = [self.leader(i) for i in range(self._n)]",
            "        result = [[] for _ in range(self._n)]",
            "        for i in range(self._n): result[leader_buf[i]].append(i)",
            "        return [r for r in result if r != []]"
        ],
        "description": [
            "https://qiita.com/R_olldIce/items/93b8f13e0d33da4ac331"
        ],
        "prefix": "DSU"
    },
    "Dijkstra": {
        "body": [
            "from heapq import heappush, heappop",
            "",
            "",
            "class Dijkstra:",
            "    class Edge:",
            "        def __init__(self, end, cost):",
            "            self.to = end",
            "            self.cost = cost",
            "",
            "    def __init__(self, node_size, inf):",
            "        self._node = node_size",
            "        self._graph = [[] for _ in range(self._node)]",
            "        self.inf = inf",
            "        self.dist = [self.inf for _ in range(self._node)]",
            "",
            "    def add_edge(self, st, ed, cost):",
            "        self._graph[st].append(self.Edge(ed, cost))",
            "        self._graph[ed].append(self.Edge(st, cost))",
            "",
            "    def solve(self, start):",
            "        que = []",
            "        self.dist[start] = 0",
            "        heappush(que, (0, start))",
            "        while que:",
            "            cur_cost, cur_vertex = heappop(que)",
            "            if self.dist[cur_vertex] < cur_cost:",
            "                continue",
            "            for e in self._graph[cur_vertex]:",
            "                if self.dist[e.to] > cur_cost + e.cost:",
            "                    self.dist[e.to] = cur_cost + e.cost",
            "                    heappush(que, (self.dist[e.to], e.to))"
        ],
        "description": [
            "https://kopricky.github.io/code/For_Python/dijkstra.html"
        ],
        "prefix": "Dijkstra"
    },
    "FenwickTree": {
        "body": [
            "class FenwickTree:",
            "    def __init__(self, n):",
            "        self._n = n",
            "        self.data = [0] * n",
            "",
            "    def add(self, p, x):",
            "        assert 0 <= p < self._n",
            "        p += 1",
            "        while p <= self._n:",
            "            self.data[p - 1] += x",
            "            p += p & -p",
            "",
            "    def sum(self, l, r):",
            "        assert 0 <= l <= r <= self._n",
            "        return self._sum(r) - self._sum(l)",
            "",
            "    def _sum(self, r):",
            "        s = 0",
            "        while r > 0:",
            "            s += self.data[r - 1]",
            "            r -= r & -r",
            "        return s"
        ],
        "description": [
            "https://qiita.com/R_olldIce/items/f2f7930e7f67963f0493"
        ],
        "prefix": "FenwickTree"
    },
    "Namori": {
        "body": [
            "import sys",
            "from collections import deque",
            "",
            "sys.setrecursionlimit(10**9)",
            "",
            "",
            "class Namori:",
            "    def __init__(self, node_size):",
            "        self.V = node_size",
            "        self.G = [[] for _ in range(self.V)]",
            "        self.deg = [0 for _ in range(self.V)]",
            "        self.loop = []",
            "        self.root = [-1 for _ in range(self.V)]",
            "        self.flag = [False for _ in range(self.V)]",
            "",
            "    def add_edge(self, u, v):",
            "        self.G[u].append(v)",
            "        self.G[v].append(u)",
            "        self.deg[u] += 1",
            "        self.deg[v] += 1",
            "",
            "    def dfs(self, u):",
            "        self.loop.append(u)",
            "        for v in self.G[u]:",
            "            if self.flag[v]: continue",
            "            self.flag[v] = True",
            "            self.dfs(v)",
            "",
            "    def build(self):",
            "        self.graph = [[] for _ in range(self.V)]",
            "        self.que = deque()",
            "",
            "        for i in range(self.V):",
            "            if self.deg[i] == 1:",
            "                self.que.append(i)",
            "                self.flag[i] = True",
            "",
            "        while self.que:",
            "            p = self.que.popleft()",
            "            for v in self.G[p]:",
            "                if self.flag[v]: continue",
            "                self.deg[v] -= 1",
            "                self.graph[v].append(p)",
            "                self.graph[p].append(v)",
            "                if self.deg[v] > 1: continue",
            "                self.que.append(v)",
            "                self.flag[v] = True",
            "",
            "        for i in range(self.V):",
            "            if self.flag[i]: continue",
            "            self.flag[i] = True",
            "            self.dfs(i)",
            "            break",
            "",
            "        for r in self.loop:",
            "            deq = deque([r])",
            "            while deq:",
            "                p = deq.popleft()",
            "                if self.root[p] >= 0: continue",
            "                self.root[p] = r",
            "                for v in self.graph[p]:",
            "                    if self.root[v] >= 0: continue",
            "                    deq.append(v)"
        ],
        "description": [
            "https://kopricky.github.io/code/GraphDecomposition/namori.html"
        ],
        "prefix": "Namori"
    },
    "SegTree": {
        "body": [
            "class SegTree:",
            "    def __init__(self, op, e, n, v=None):",
            "        self._op = op",
            "        self._e = e",
            "        self._n = n",
            "        self._log = (n - 1).bit_length()",
            "        self._size = 1 << self._log",
            "        self._d = [self._e()] * (self._size << 1)",
            "        if v is not None:",
            "            for i in range(self._n):",
            "                self._d[self._size + i] = v[i]",
            "            for i in range(self._size - 1, 0, -1):",
            "                self._d[i] = self._op(self._d[i << 1], self._d[i << 1 | 1])",
            "",
            "    def set(self, p, x):",
            "        p += self._size",
            "        self._d[p] = x",
            "        while p:",
            "            self._d[p >> 1] = self._op(self._d[p], self._d[p ^ 1])",
            "            p >>= 1",
            "",
            "    def get(self, p): return self._d[p + self._size]",
            "",
            "    def prod(self, l, r):",
            "        sml, smr = self._e(), self._e()",
            "        l += self._size",
            "        r += self._size",
            "        while l < r:",
            "            if l & 1:",
            "                sml = self._op(sml, self._d[l])",
            "                l += 1",
            "            if r & 1:",
            "                r -= 1",
            "                smr = self._op(self._d[r], smr)",
            "            l >>= 1",
            "            r >>= 1",
            "        return self._op(sml, smr)",
            "",
            "    def all_prod(self): return self._d[1]"
        ],
        "description": [
            "https://qiita.com/R_olldIce/items/f2f7930e7f67963f0493"
        ],
        "prefix": "SegTree"
    },
    "inv_gcd": {
        "body": [
            "def inv_gcd(a, b):",
            "    a %= b",
            "    if a == 0: return b, 0",
            "    s, t = b, a",
            "    m0, m1 = 0, 1",
            "    while t:",
            "        u = s // t",
            "",
            "        s -= t * u",
            "        m0 -= m1 * u",
            "",
            "        s, t = t, s",
            "        m0, m1 = m1, m0",
            "",
            "    if m0 < 0: m0 += b // s",
            "    return s, m0"
        ],
        "description": [
            "https://qiita.com/R_olldIce/items/cebb1f15bf482fddd85e#3-inv_gcd"
        ],
        "prefix": "inv_gcd"
    }
}