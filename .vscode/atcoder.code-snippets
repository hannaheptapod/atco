{
    "Namori": {
        "body": [
            "import sys",
            "from collections import deque",
            "",
            "sys.setrecursionlimit(10**9)",
            "",
            "",
            "class Namori:",
            "    def __init__(self, node_size):",
            "        self.V = node_size",
            "        self.G = [[] for _ in range(self.V)]",
            "        self.deg = [0 for _ in range(self.V)]",
            "        self.loop = []",
            "        self.root = [-1 for _ in range(self.V)]",
            "        self.flag = [False for _ in range(self.V)]",
            "",
            "    def add_edge(self, u, v):",
            "        self.G[u].append(v)",
            "        self.G[v].append(u)",
            "        self.deg[u] += 1",
            "        self.deg[v] += 1",
            "",
            "    def dfs(self, u):",
            "        self.loop.append(u)",
            "        for v in self.G[u]:",
            "            if self.flag[v]: continue",
            "            self.flag[v] = True",
            "            self.dfs(v)",
            "",
            "    def build(self):",
            "        self.graph = [[] for _ in range(self.V)]",
            "        self.que = deque()",
            "",
            "        for i in range(self.V):",
            "            if self.deg[i] == 1:",
            "                self.que.append(i)",
            "                self.flag[i] = True",
            "",
            "        while self.que:",
            "            p = self.que.popleft()",
            "            for v in self.G[p]:",
            "                if self.flag[v]: continue",
            "                self.deg[v] -= 1",
            "                self.graph[v].append(p)",
            "                self.graph[p].append(v)",
            "                if self.deg[v] > 1: continue",
            "                self.que.append(v)",
            "                self.flag[v] = True",
            "",
            "        for i in range(self.V):",
            "            if self.flag[i]: continue",
            "            self.flag[i] = True",
            "            self.dfs(i)",
            "            break",
            "",
            "        for r in self.loop:",
            "            deq = deque([r])",
            "            while deq:",
            "                p = deq.popleft()",
            "                if self.root[p] >= 0: continue",
            "                self.root[p] = r",
            "                for v in self.graph[p]:",
            "                    if self.root[v] >= 0: continue",
            "                    deq.append(v)"
        ],
        "description": "Namori",
        "prefix": "Namori"
    },
    "SegTree": {
        "body": [
            "class SegTree:",
            "    def __init__(self, op, e, n, v=None):",
            "        self._op = op",
            "        self._e = e",
            "        self._n = n",
            "        self._log = (n - 1).bit_length()",
            "        self._size = 1 << self._log",
            "        self._d = [self._e()] * (self._size << 1)",
            "        if v is not None:",
            "            for i in range(self._n):",
            "                self._d[self._size + i] = v[i]",
            "            for i in range(self._size - 1, 0, -1):",
            "                self._d[i] = self._op(self._d[i << 1], self._d[i << 1 | 1])",
            "",
            "    def set(self, p, x):",
            "        p += self._size",
            "        self._d[p] = x",
            "        while p:",
            "            self._d[p >> 1] = self._op(self._d[p], self._d[p ^ 1])",
            "            p >>= 1",
            "",
            "    def get(self, p): return self._d[p + self._size]",
            "",
            "    def prod(self, l, r):",
            "        sml, smr = self._e(), self._e()",
            "        l += self._size",
            "        r += self._size",
            "        while l < r:",
            "            if l & 1:",
            "                sml = self._op(sml, self._d[l])",
            "                l += 1",
            "            if r & 1:",
            "                r -= 1",
            "                smr = self._op(self._d[r], smr)",
            "            l >>= 1",
            "            r >>= 1",
            "        return self._op(sml, smr)",
            "",
            "    def all_prod(self): return self._d[1]"
        ],
        "description": "SegTree",
        "prefix": "SegTree"
    },
    "pow_mod": {
        "body": [
            "def pow_mod(a, n, mod=MOD):",
            "    if not n: return 1",
            "    return (a*pow_mod(a, n-1) if n%2 else pow_mod(a**2%mod, n>>1))%mod"
        ],
        "description": "pow_mod",
        "prefix": "pow_mod"
    }
}
